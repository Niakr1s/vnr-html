<html lang="ja">

<head>
	<meta charset="utf-8">
	<title>Visual Novel Reader</title>
	<style type="text/css">
		body {
			background-color: #202020;
			color: #BCBCBC;
		}

		.flex {
			display: flex;
		}

		.flex > * {
			display: inline-block;
			vertical-align: middle;
		}

		.flex-right {
			margin-left: auto;
		}

		.flex-left {
			margin-right: auto;
		}

		form {
			margin: 0;
		}

		.text_history_status {
			font-size: 12px;
			margin-left: 10px;
		}

		.current_line {
			margin: 20px 10px 10px 10px;
			font-size: 40px;
		}

		button {
			border: none;
			outline: none;
			background-color: transparent;
		}

		.red {
			color: red;
		}

		.green {
			color: green;
		}

		.white {
			color: #BCBCBC;
		}

		.bottom {
			position: absolute;
			bottom: 0px;
			left: 10px;
			right: 10px;
		}

		.translation {
			font-size: 20px;
		}

		.homepage {
			font-size: 12px;
		}

		.lang {
			background-color: transparent;
			border: none;
			color: #BCBCBC;
		}
	</style>
</head>

<body id="body">
	<div class="flex">
		<div class="homepage"><a href="https://github.com/Niakr1s/vnr-html">github</a></div>
		
		<select id="lang" class="lang flex-right">
			<option value="ru">ru</option>
			<option value="en">en</option>
		</select>
		
		<button id="delete_button" class="red"><</button>
		<button id="prev_button" class="green"><</button>
		<button id="next_button" class="green">></button>
		<button id="last_button" class="green">>></button>
		<div id="text_history_status" class="text_history_status"></div>
		<button id="copy_button" class="white">copy</button>
	</div>

	<div class="bottom">
		<div id="translation" class="translation"></div>
	</div>
		
	<div id="current_line" class="current_line"></div>

	<script>
		class TranslationRequest {
			_memory = {};

			// cb: ({ translation: string }) => void
			constructor(cb) {
				this._cb = cb;
			}

			async translate(options = { sourceLangauge, targetLanguage, sentence }) {
				options = {
					sentence: '',
					sourceLangauge: 'auto',
					targetLanguage: 'en',

					...options,
				}

				if (this._memory[options.sentence]) return;
				this._memory[options.sentence] = true;

				try {
					console.log(`fetching translation for ${options.sentence}`)
					const res = await fetch(`http://localhost:53532/translate/${options.sentence}/${options.sourceLangauge}/${options.targetLanguage}`);
					this._cb(JSON.parse(await res.json()));
				} catch {

				} finally {
					delete this._memory[options.sentence];
				}
			}
		}

		class Emitter {
			_callbacks = [];
			onUpdate(cb) {
				this._callbacks.push(cb);
			}
			emit() {
				this._callbacks.forEach((cb) => cb());
			}
		}

		const modelUpdatedEmitter = new Emitter();

		const textHistory = {
			// { textLine, translation }
			queue: [],
			max: 99,
			current: 0,
			
			isEmpty() {
				return this.queue.length === 0;
			},
			isLast() {
				if (this.queue.length === 0) return true;
				return this.current === this.queue.length - 1;
			},
			isFirst() {
				return this.current === 0;
			},

			fixCurrentBounded() {
				if (this.queue.length === 0) {
					this.current = 0;
				} else {
					if (this.current >= this.queue.length) {
						this.last();
					}
				}
				if (this.current < 0) this.first();
				modelUpdatedEmitter.emit();
			},

			push(textLine) {
				this.queue.push({ textLine });
				while (this.queue.length > this.max) {
					this.queue.shift();
				}
				this.last();
				modelUpdatedEmitter.emit();
			},

			addTranslation(options = { textLine, translation, targetLanguage }) {
				const { textLine, translation, targetLanguage } = options;
				console.log('addTranslation:', options)
				this.queue = this.queue.map((el, idx) => {
					if (el.textLine !== textLine) return el;
					el.translation ||= {};
					el.translation[targetLanguage] = translation;
					return el;
				})
				modelUpdatedEmitter.emit();
			},

			delete() {
				if (this.queue.length === 0) return;
				this.queue.splice(this.current, 1);
				this.prev();
				this.fixCurrentBounded();
				modelUpdatedEmitter.emit();
			},
			prev() {
				this.current--;
				this.fixCurrentBounded();
				modelUpdatedEmitter.emit();
			},
			next() {
				this.current++;
				this.fixCurrentBounded();
				modelUpdatedEmitter.emit();
			},
			first() {
				this.current = 0;
				modelUpdatedEmitter.emit();
			},
			last() {
				this.current = this.queue.length === 0 ? 0 : this.queue.length - 1;
				modelUpdatedEmitter.emit();
			},

			getCurrentLine() {
				if (this.current < 0) return;
				return this.queue[this.current];
			}
		}

		const clipboard = {
			_lastTextLine: '',

			setLastTextLine(text) {
				clipboard._lastTextLine = text;
			},

			copy(containerid) {
				const result = {
					copied: true,
				}

				const element = document.getElementById(containerid);
				if (element.textContent === this._lastTextLine) return {...result, copied: false};

				const range = document.createRange();
				range.selectNode(document.getElementById(containerid));
				window.getSelection().addRange(range);
				document.execCommand("copy");
				window.getSelection().removeRange(range);
				return result;
			},
		}

		const clipboardObserver = {
			skipNextClipboard: false,

			addToTextHistory(textLine) {
				if (!this.skipNextClipboard) {
					textHistory.push(textLine);
				}
				this.skipNextClipboard = false;
			},

			observer: new MutationObserver((mutationList, observer) => {
				let ps = document.getElementsByTagName('p');

				// removing all except last
				while (ps.length > 0) {
					const textLine = ps[0].textContent;
					clipboard.setLastTextLine(textLine);
					ps[0].remove();
					clipboardObserver.addToTextHistory(textLine);
				}
			}),

			start() {
				this.observer.observe(document.getElementById('body'), { childList: true });
			},
		}

		const gui = {
			init() {
				this.buttons.init();
				this.langSelector.init();
				this.update();
				modelUpdatedEmitter.onUpdate(this.update.bind(this));
			},

			langSelector: {
				element: document.getElementById("lang"),
				getTargetLanguage() {
					return this.element.value || 'en';
				},
				init() {
					this.element.onchange = function() {
						modelUpdatedEmitter.emit();
					}
				},
			},

			buttons: {
				copyButton: document.getElementById("copy_button"),
				deleteButton: document.getElementById("delete_button"),
				prevButton: document.getElementById("prev_button"),
				nextButton: document.getElementById("next_button"),
				lastButton: document.getElementById("last_button"),

				updatePrevButton() {
					if (textHistory.isFirst()) {
						this.prevButton.disabled = true;
					} else {
						this.prevButton.disabled = false;
					}
				},
				updateNextButton() {
					if (textHistory.isLast()) {
						this.nextButton.disabled = true;
					} else {
						this.nextButton.disabled = false;
					}
				},
				updateDeleteButton() {
					if (textHistory.isEmpty()) {
						this.deleteButton.disabled = true;
					} else {
						this.deleteButton.disabled = false;
					}
				},

				init(){
					this.copyButton.onclick = () => {
						const { copied } = clipboard.copy('current_line');
						clipboardObserver.skipNextClipboard |= copied;
					};

					this.prevButton.onclick = () => {
						textHistory.prev();
					};

					this.nextButton.onclick = () => {
						textHistory.next();
					};

					this.deleteButton.onclick = () => {
						textHistory.delete();
					};

					this.lastButton.onclick = () => {
						textHistory.last();
					};
				},
			},

			update() {
				this.showCurrentLine();
				this.showTextHistoryStatus();
				this.updateButtons();
			},
			showCurrentLine() {
				const currentLine = textHistory.getCurrentLine();
				if (!currentLine) return;
				let currentLineElement = document.getElementById('current_line');
				currentLineElement.textContent = currentLine.textLine;
				
				let translationElement = document.getElementById('translation');
				const targetLanguage = gui.langSelector.getTargetLanguage();
				if (currentLine.translation && currentLine.translation[targetLanguage]) {
					translationElement.textContent = currentLine.translation[targetLanguage];
				} else {
					translationElement.textContent = '';
				}
			},
			showTextHistoryStatus() {
				let textHistoryStatusElement = document.getElementById('text_history_status');

				function makeTextContent(current, max) {
					return `${current}/${max}`;
				};

				textHistoryStatusElement.textContent = textHistory.isEmpty() ? makeTextContent(0, 0) : makeTextContent(textHistory.current + 1, textHistory.queue.length);
			},
			updateButtons() {
				this.buttons.updateDeleteButton();
				this.buttons.updateNextButton();
				this.buttons.updatePrevButton();
			},
		}

		clipboardObserver.start();
		gui.init();

		const translationElement = document.getElementById('translation');
		const translationRequest = new TranslationRequest(({ translation, sentence, targetLanguage }) => {
			textHistory.addTranslation({ textLine: sentence, translation, targetLanguage });
		});

		modelUpdatedEmitter.onUpdate(() => {
			const { textLine, translation } = textHistory.getCurrentLine();
			const targetLanguage = gui.langSelector.getTargetLanguage();
			if (translation && translation[targetLanguage]) return;

			translationRequest.translate({
				sentence: textLine,
				targetLanguage,
			})
		})
	</script>
</body>

</html>